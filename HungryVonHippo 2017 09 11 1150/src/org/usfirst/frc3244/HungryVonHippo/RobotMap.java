// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3244.HungryVonHippo;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.CANTalon;

import edu.wpi.first.wpilibj.ADXRS450_Gyro;
import edu.wpi.first.wpilibj.AnalogPotentiometer;
import edu.wpi.first.wpilibj.BuiltInAccelerometer;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Relay;
import edu.wpi.first.wpilibj.Servo;
import edu.wpi.first.wpilibj.Spark;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.VictorSP;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

//Manually Configured Imports
import edu.wpi.first.wpilibj.SerialPort;
import edu.wpi.first.wpilibj.I2C;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import com.ctre.CANTalon.FeedbackDevice;
import com.ctre.CANTalon.TalonControlMode;
import com.kauailabs.navx.frc.AHRS;

/**
 * The RobotMap is a mapping from the ports sensors and actuators are wired into
 * to a variable name. This provides flexibility changing wiring, makes checking
 * the wiring easier and significantly reduces the number of magic numbers
 * floating around.
 */
public class RobotMap {
	public static CANTalon drivemotor_Front_Left;
    public static CANTalon drivemotor_Front_Right;
    public static CANTalon drivemotor_Back_Left;
    public static CANTalon drivemotor_Back_Right;
    public static BuiltInAccelerometer roboRioAccelerometer ; 
    
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static SpeedController winchmotor_Winch;
    public static DigitalInput winchlimitSwitch_Left;
    public static DigitalInput winchlimitSwitch_Right;
    public static SpeedController fuelIntakemotor_IntakeRoller;
    public static AnalogPotentiometer wristPot;
    public static SpeedController wristmotor;
    public static SpeedController flyWheelmotor_Indexer;
    public static CANTalon flyWheelmotor_FlyWheel;
    public static Relay vision_hardwarelights_Left_and_Forward;
    public static Relay vision_hardwarelights_Right;
    public static Servo elevatorServoservo_Elevator;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    public static DigitalInput functionJumpperVision;
    public static AHRS ahrs;
    public static ADXRS450_Gyro adrxs450_Gyro;
    
    //PDP Channles
    public static final int DRIVE_BACK_RIGHT_PDP = 0;
	public static final int DRIVE_FRONT_RIGHT_PDP = 1;
	public static final int WINCH_PDP = 2;
	public static final int NC3 = 3;
	public static final int WRIST_PDP = 4;
	public static final int KANGAROO_POWER_PDP = 5;
	public static final int VOLTMETER_PDP = 6;
	public static final int NC7_PDP = 7;
	public static final int LIGHTS_SPIKE1_PDP = 8;
	public static final int LIGHTS_SPIKE2_PDP = 9;
	public static final int INTAKE_PDP = 10;
	public static final int FUEL_INDEXER_PDP = 11;
	public static final int NC12_PDP = 12;
	public static final int DRIVE_FRONT_LEFT_PDP = 13;
	public static final int FLYWHEEL_PDP = 14;
	public static final int DRIVE_BACK_LEFT_PDP = 15;
	
	//public static boolean isCompetitionBot = true;
    public static boolean isCompetitionBot = false; 
    
	//Start Code to use the NorticSpeedControler
    public enum RobotDriveTrainSettings {
    	FORWARD_BACKWARD_FACTOR(1,.5),
    	ROTATION_FACTOR(1.25,.5),
     	STRAFE_FACTOR(2,.75);
	
		private final double m_competitionSetting;
		private final double m_practiceSetting;
		
		public double get() {
			return isCompetitionBot ? m_competitionSetting : m_practiceSetting; 
		}
		
		RobotDriveTrainSettings(double competitionSetting, double practiceSetting) {
	    	m_competitionSetting = competitionSetting;
	    	m_practiceSetting = practiceSetting;
		}
	}
	
	static void init() { 
		
		roboRioAccelerometer = new BuiltInAccelerometer();
		
		//Not Letting RobotBuilder Manage These Anymore
		drivemotor_Front_Left = new CANTalon(2);//1);
        LiveWindow.addActuator("Drive", "motor_Front_Left", drivemotor_Front_Left);
        
        drivemotor_Front_Right = new CANTalon(4);//2);
        LiveWindow.addActuator("Drive", "motor_Front_Right", drivemotor_Front_Right);
        
        drivemotor_Back_Left = new CANTalon(1);//3);
        LiveWindow.addActuator("Drive", "motor_Back_Left", drivemotor_Back_Left);
        
        drivemotor_Back_Right = new CANTalon(3);//4);
        LiveWindow.addActuator("Drive", "motor_Back_Right", drivemotor_Back_Right);
        
        
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        winchmotor_Winch = new VictorSP(1);
        LiveWindow.addActuator("Winch", "motor_Winch", (VictorSP) winchmotor_Winch);
        
        winchlimitSwitch_Left = new DigitalInput(0);
        LiveWindow.addSensor("Winch", "limitSwitch_Left", winchlimitSwitch_Left);
        
        winchlimitSwitch_Right = new DigitalInput(1);
        LiveWindow.addSensor("Winch", "limitSwitch_Right", winchlimitSwitch_Right);
        
        fuelIntakemotor_IntakeRoller = new VictorSP(2);
        LiveWindow.addActuator("Fuel Intake", "motor_IntakeRoller", (VictorSP) fuelIntakemotor_IntakeRoller);
        
        wristPot = new AnalogPotentiometer(2, 270.0, -82.3);
        LiveWindow.addSensor("Wrist", "Pot", wristPot);
        
        wristmotor = new Spark(3);
        LiveWindow.addActuator("Wrist", "motor", (Spark) wristmotor);
        
        flyWheelmotor_Indexer = new VictorSP(5);
        LiveWindow.addActuator("FlyWheel", "motor_Indexer", (VictorSP) flyWheelmotor_Indexer);
        
        flyWheelmotor_FlyWheel = new CANTalon(5);
        LiveWindow.addActuator("FlyWheel", "motor_FlyWheel", flyWheelmotor_FlyWheel);
        
        vision_hardwarelights_Left_and_Forward = new Relay(0);
        LiveWindow.addActuator("Vision_hardware", "lights_Left_and_Forward", vision_hardwarelights_Left_and_Forward);
        
        vision_hardwarelights_Right = new Relay(1);
        LiveWindow.addActuator("Vision_hardware", "lights_Right", vision_hardwarelights_Right);
        
        elevatorServoservo_Elevator = new Servo(4);
        LiveWindow.addActuator("ElevatorServo", "servo_Elevator", elevatorServoservo_Elevator);
        

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        // Some DIO To Work with
        functionJumpperVision = new DigitalInput(9);
        LiveWindow.addSensor("Function_Jumpers", "Vision", functionJumpperVision);
        
        // Invert Motors
        fuelIntakemotor_IntakeRoller.setInverted(true);
        winchmotor_Winch.setInverted(true);
        flyWheelmotor_Indexer.setInverted(true);
        
        // Invert Encoders
      
        /* first choose the sensor */
        flyWheelmotor_FlyWheel.setFeedbackDevice(FeedbackDevice.QuadEncoder);
        flyWheelmotor_FlyWheel.reverseSensor(true);
        flyWheelmotor_FlyWheel.configEncoderCodesPerRev(80); // if using FeedbackDevice.QuadEncoder
        //_talon.configPotentiometerTurns(XXX), // if using FeedbackDevice.AnalogEncoder or AnalogPot

        /* set the peak and nominal outputs, 12V means full */
        flyWheelmotor_FlyWheel.configNominalOutputVoltage(+0.0f, -0.0f);
        flyWheelmotor_FlyWheel.configPeakOutputVoltage(+12.0f, -0.0f);
        /* set closed loop gains in slot0 */
        flyWheelmotor_FlyWheel.setProfile(0);
        flyWheelmotor_FlyWheel.setF(2.13);
        flyWheelmotor_FlyWheel.setP(0);
        flyWheelmotor_FlyWheel.setI(0); 
        flyWheelmotor_FlyWheel.setD(0);
        flyWheelmotor_FlyWheel.changeControlMode(TalonControlMode.Speed);
        flyWheelmotor_FlyWheel.setVoltageRampRate(24.0);
        //Create Gyro
        try {
        	System.out.println("Hello Tying to INIT Navx");
            /* Communicate w/navX MXP via the MXP SPI Bus.                                     */
            /* Alternatively:  I2C.Port.kMXP, SerialPort.Port.kMXP or SerialPort.Port.kUSB     */
            /* See http://navx-mxp.kauailabs.com/guidance/selecting-an-interface/ for details. */
        
            //ahrs = new AHRS(SPI.Port.kMXP); 
        	//ahrs = new AHRS(I2C.Port.kMXP);
        	ahrs = new AHRS(SerialPort.Port.kUSB);
            //ahrs = new AHRS(I2C.Port.kOnboard); 
        	//ahrs = new AHRS(I2C.Port.kOnboard,(byte)200);
            
        } catch (RuntimeException ex ) {
        	System.out.println("Hello from the Navx runtimeExcept");
            DriverStation.reportError("Error instantiating navX MXP:  " + ex.getMessage(), true);
        }
        
        try{
        	DriverStation.reportWarning("Init ADXRS450_Gyro", false);
        	adrxs450_Gyro = new ADXRS450_Gyro();
        }catch (RuntimeException ex ) {
        	System.out.println("Hello from the adrxs450_Gyro runtimeExcept");
            DriverStation.reportError("Error instantiating adrxs450_Gyro:  " + ex.getMessage(), true);
        }
            Timer.delay(2);
    }
}
