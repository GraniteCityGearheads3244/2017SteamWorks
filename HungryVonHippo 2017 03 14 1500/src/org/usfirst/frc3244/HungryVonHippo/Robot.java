// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3244.HungryVonHippo;

import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.DriverStation.Alliance;
import edu.wpi.first.wpilibj.IterativeRobot;
import edu.wpi.first.wpilibj.PowerDistributionPanel;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import org.usfirst.frc3244.HungryVonHippo.autonomousroutines.*;
import org.usfirst.frc3244.HungryVonHippo.commands.*;
import org.usfirst.frc3244.HungryVonHippo.subsystems.*;
import org.usfirst.frc3244.HungryVonHippo.util.Utils;


/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the IterativeRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the manifest file in the resource
 * directory.
 */
public class Robot extends IterativeRobot {

    //public static final boolean DEBUG = true;
    public static final boolean DEBUG = false;
    
    private Runtime runtime = Runtime.getRuntime();
    
    //Disabled variables
    private Integer scancount = 0 ;
	private Integer sequence = 0 ;
	private Integer count = 0;
   
    Command autonomousCommand;
    private String autonomousSelected;
	public static SendableChooser autonomousChooser;
	

    public static OI oi;
    public static Drive drive;
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static Winch winch;
    public static FuelIntake fuelIntake;
    public static Wrist wrist;
    public static FlyWheel flyWheel;
    public static Vision_hardware vision_hardware;
    public static ElevatorServo elevatorServo;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    public static final PowerDistributionPanel pdp = new PowerDistributionPanel();

    /**
     * This function is run when the robot is first started up and should be
     * used for any initialization code.
     */
    public void robotInit() {
    RobotMap.init();
    drive = new Drive(); //Robotbuilder No longer Mannages thsi
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        winch = new Winch();
        fuelIntake = new FuelIntake();
        wrist = new Wrist();
        flyWheel = new FlyWheel();
        vision_hardware = new Vision_hardware();
        elevatorServo = new ElevatorServo();

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        // OI must be constructed after subsystems. If the OI creates Commands
        //(which it very likely will), subsystems are not guaranteed to be
        // constructed yet. Thus, their requires() statements may grab null
        // pointers. Bad news. Don't move it.
        oi = new OI();

        // instantiate the command used for the autonomous period
        
        
        // Initialize the subsystems that need it
        drive.init();
        
        //Set up Choosers
        setupAutomousChooser();
        
        //Zero The Gyro
        //driveTrain.my_zeroHeading(true);
        
        // Start USB Camera
        vision_hardware.My_Start_USB_Camera_Right();
    }
    
    private void setupAutomousChooser(){
    	//Create the Auto Chooser
    	//SmartDashboard.putString("autonomous Title", "Autonomous Choice");
        autonomousChooser = new SendableChooser();
        autonomousChooser.addDefault("0: Reach Base Line ", new Auto_00());
        autonomousChooser.addObject("1: Do Nothing:", new Auto_01_DoNothing());
        autonomousChooser.addObject("2: Red High Goal Near Boiler", new Auto_02_Red_Near_Boiler());
        autonomousChooser.addObject("3: Red High Goal Middel Boiler", new Auto_03());
        autonomousChooser.addObject("4: Red High Goal Far Boiler", new Auto_04());
        autonomousChooser.addObject("2: Blue High Goal Near Boiler", new Auto_05());
        autonomousChooser.addObject("3: Blue High Goal Middel Boiler", new Auto_06());
        autonomousChooser.addObject("4: Blue High Goal Far Boiler", new Auto_07());
        autonomousChooser.addObject("5: Left Pin", new Auto_08());
        autonomousChooser.addObject("6: Middel Pin", new Auto_09());
        autonomousChooser.addObject("7: Right Pin", new Auto_10());
        //Add More Options
        
        //Place autonomousChooser on the SmartDashboard
        SmartDashboard.putData("Autonomous Chooser", autonomousChooser);
    }
    

    /**
     * This function is called when the disabled button is hit.
     * You can use it to reset subsystems before shutting down.
     */
    public void disabledInit(){
    	Robot.oi.launchPad.setOutputs(0);
    }

    public void disabledPeriodic() {
        Scheduler.getInstance().run();
        SmartDashboard.putNumber("Gyro",
				Utils.twoDecimalPlaces(RobotMap.ahrs.getFusedHeading()));
        
        scancount  = scancount+1;
        Robot.oi.launchPad.setOutputs(sequence);
        int pattern = 1;
		if (pattern == 0){
			if (scancount > 10){
	        	sequence = sequence+1;
	        	scancount = 0;
	        	//Test SmartDashboar Send the current AutoChoice. We found this usualy always works. The Get chooser fails when it really matters. 
	        	 autonomousSelected = autonomousChooser.getSelected().toString();
	             SmartDashboard.putString("Auto Choice", autonomousSelected);
	        }
	        if (sequence > 2048){
	        	sequence = 0;
	        }
        }
		if (pattern == 1){
			if (scancount > 10){
	        	sequence = sequence<<1;
	        	scancount = 0;
	        	count =count +1;
	        }
	        if (count == 11){
	        	sequence = sequence+1;
	        	count = 0;
	        	//Test SmartDashboar Send the current AutoChoice
	        	 autonomousSelected = autonomousChooser.getSelected().toString();
	             SmartDashboard.putString("Auto Choice", autonomousSelected);
	        }
        }
    }

    public void autonomousInit() {
    	// get Selected Autonomous
    	autonomousCommand = (Command) autonomousChooser.getSelected(); 
    	
    	// What is the name of this Autonomous? Then Send it to the divers.
    	autonomousSelected = autonomousChooser.getSelected().toString();
        SmartDashboard.putString("autonomousInit Auto Choice", autonomousSelected);
        
        //Turn Off the LED on the Diverstation Controler.
    	Robot.oi.launchPad.setOutputs(0);
    	
        // schedule the autonomous command (example)
        if (autonomousCommand != null) autonomousCommand.start();
    }


	/**
     * This function is called periodically during autonomous
     */
    public void autonomousPeriodic() {
        Scheduler.getInstance().run();
    }

    public void teleopInit() {
        // This makes sure that the autonomous stops running when
        // teleop starts running. If you want the autonomous to
        // continue until interrupted by another command, remove
        // this line or comment it out.
        if (autonomousCommand != null) autonomousCommand.cancel();
        
        DriverStation.reportError("My Entering Teleop.", false);
        Robot.drive.clearDesiredHeading();
    }

    boolean teleopOnce = false;
    
    /**
     * This function is called periodically during operator control
     */
    public void teleopPeriodic() {
        if (!teleopOnce)
    	{
    	  DriverStation.reportError("My Teleop Periodic is running!", false);
    	}
    	teleopOnce = true;
        Scheduler.getInstance().run();
            
        // update sensors in drive that need periodic update
        //drive.periodic();
//        elevator.periodic();
        
        drive.mecanumDriveTeleop(oi.driveX(), oi.driveY(), oi.driveRotation()); 
        
        updateSmartDashboard();
        
    }

    /**
     * This function is called periodically during test mode
     */
    public void testPeriodic() {
        LiveWindow.run();
    }
    
    private long SMART_DASHBOARD_UPDATE_INTERVAL = 250;
    private long nextSmartDashboardUpdate = System.currentTimeMillis();
    
    public void updateSmartDashboard() {
        try {
            if (System.currentTimeMillis() > nextSmartDashboardUpdate) {
                // display free memory for the JVM
            	double freeMemoryInKB = runtime.freeMemory() / 1024;
                SmartDashboard.putNumber("Free Memory", freeMemoryInKB); 
                
                SmartDashboard.putNumber("Battery Voltage", pdp.getVoltage());
                
                SmartDashboard.putNumber("X box x:", oi.driveX());
                SmartDashboard.putNumber("X box y:", oi.driveY());
                SmartDashboard.putNumber("X box r:", oi.driveRotation());
            	// display mode information
//                SmartDashboard.putBoolean("Is Teleop", DriverStation.getInstance().isOperatorControl());
//                SmartDashboard.putBoolean("Is Autonomous", DriverStation.getInstance().isAutonomous());
//                SmartDashboard.putBoolean("Is Enabled", DriverStation.getInstance().isEnabled());

            	// display interesting OI information
//                SmartDashboard.putNumber("DriveX", oi.driveX());  
//                SmartDashboard.putNumber("DriveY", oi.driveY());  
//                SmartDashboard.putNumber("DriveRotation", oi.driveRotation());  
                
            	drive.updateSmartDashboard();
            	flyWheel.updateSmartDashboard();
//            	elevator.updateSmartDashboard();
            	//pole.updateSmartDashboard();
            	
 
                nextSmartDashboardUpdate += SMART_DASHBOARD_UPDATE_INTERVAL;
            }
        } catch (Exception e) {
           return;
        }
    }
    
}
