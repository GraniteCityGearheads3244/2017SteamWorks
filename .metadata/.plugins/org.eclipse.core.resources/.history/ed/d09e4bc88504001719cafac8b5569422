// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3244.HungryVonHippo.subsystems;

import org.usfirst.frc3244.HungryVonHippo.Robot;
import org.usfirst.frc3244.HungryVonHippo.RobotMap;
import org.usfirst.frc3244.HungryVonHippo.commands.*;
import org.usfirst.frc3244.HungryVonHippo.util.Utils;

import com.ctre.CANTalon;
import com.ctre.CANTalon.FeedbackDevice;
import com.ctre.CANTalon.TalonControlMode;
import com.kauailabs.navx.frc.AHRS;

import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;


/**
 *
 */
public class Drive extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
    public static final double HIGHGOAL_SERVO_POS_AUTO = .5;
    public static final double HIGHGOAL_FLYWHEEL_SPEED_AUTO = 80;
    public static final double INDEXER_FEEDRATE_HIGHSPEED = 100;
    public static final double INDEXER_FEEDRATE_MEDSPEED = 75;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS


    private AHRS headingGyro = RobotMap.ahrs;
    
    private final CANTalon front_Left = RobotMap.drivemotor_Front_Left;
    private final CANTalon front_Right = RobotMap.drivemotor_Front_Right;
    private final CANTalon back_Left = RobotMap.drivemotor_Back_Left;
    private final CANTalon back_Right = RobotMap.drivemotor_Back_Right;

 // member variables for Mecanum drive
 	private static final int kMaxNumberOfMotors = 4;
 	private final int m_invertedMotors[] = new int[kMaxNumberOfMotors];
 	private static final int kFrontLeft = 0;
 	private static final int kFrontRight = 1;
 	private static final int kBackLeft = 2;
 	private static final int kBackRight = 3;


 	// create objects needed for independent control of each wheel
 	private CANTalon[] m_talons = new CANTalon[kMaxNumberOfMotors];
 	private double m_wheelSpeeds[] = new double[kMaxNumberOfMotors];
 	private double m_zeroPositions[] = new double[kMaxNumberOfMotors];

 	private boolean m_useVoltageRamp = true;
 	private double m_voltageRampRate = 25.0;//48.0; // in volts/second
 	private boolean m_breakMode = false;
 	private boolean m_fieldOrientedDrive = false;

 	private int m_iterationsSinceRotationCommanded = 0;
 	private double m_desiredHeading = 0.0;
 	private boolean m_drivingAutoInTeleop = false;
 	
 	// driving scaling factors
 	private static final double FORWARD_BACKWARD_FACTOR = 1.0;
 	private static final double ROTATION_FACTOR = 1.25;
 	private static final double STRAFE_FACTOR = 2.0;
 	private static final double SLOW_FACTOR = 0.35; // scaling factor for (normal) "slow mode"
 	private static final double CRAWL_INPUT = 0.3; // "crawl" is a gentle control input
 	public static final double ALIGN_SPEED = 0.10;

 	// member variables to support closed loop mode
 	private boolean m_closedLoopMode = true;
 	private double m_maxWheelSpeed = 360;//550.0;     // empirically measured around 560 to 580	
  

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public Drive() {
    	int talonIndex = 0;

    	// construct the talons
    	m_talons[kFrontLeft] = front_Left;
    	m_talons[kFrontRight] = front_Right;
    	m_talons[kBackLeft] = back_Left;
    	m_talons[kBackRight] = back_Right;

    	// set all Talon SRX encoder values to zero
		for (talonIndex = 0; talonIndex < kMaxNumberOfMotors; talonIndex++) {
			m_talons[talonIndex].setPosition(0);
		}
		
		// set all the Talon feedback Devices
		for (talonIndex = 0; talonIndex < kMaxNumberOfMotors; talonIndex++) {
			m_talons[talonIndex].setFeedbackDevice(FeedbackDevice.CtreMagEncoder_Relative);
		}
		
		// Configure Nominal Output Voltage
		for (talonIndex = 0; talonIndex < kMaxNumberOfMotors; talonIndex++) {
			m_talons[talonIndex].configNominalOutputVoltage(+0.0f, -0.0f);
		}
		
		// Configure Peak Output Voltage
		for (talonIndex = 0; talonIndex < kMaxNumberOfMotors; talonIndex++) {
			m_talons[talonIndex].configPeakOutputVoltage(+12.0f, -12.0f);
		}
		
		// set all the Talon SRX encoders to reverce
		for (talonIndex = 0; talonIndex < kMaxNumberOfMotors; talonIndex++) {
			m_talons[talonIndex].reverseSensor(true);
		}

		// put all Talon SRX into brake mode
		for (talonIndex = 0; talonIndex < kMaxNumberOfMotors; talonIndex++) {
			m_talons[talonIndex].enableBrakeMode(m_breakMode);
		}

		// ensure ramp rate set accordingly
		if (m_useVoltageRamp) {
			for (talonIndex = 0; talonIndex < kMaxNumberOfMotors; talonIndex++) {
				m_talons[talonIndex].setVoltageRampRate(m_voltageRampRate);
			}
		} else {
			// clear all voltage ramp rates
			for (talonIndex = 0; talonIndex < kMaxNumberOfMotors; talonIndex++) {
				m_talons[talonIndex].setVoltageRampRate(0.0);
			}
		}
		// Also need to set up the "inverted motors" array for the mecanum drive
		// code
		m_invertedMotors[kFrontLeft] = 1;
		m_invertedMotors[kFrontRight] = -1;
		m_invertedMotors[kBackLeft] = 1;
		m_invertedMotors[kBackRight] = -1;
    }
    
    public void init() {
		// complete initialization here that can't be performed in constructor
		// (some calls can't be made in constructor because other objects don't
		// yet exist)

		// Set up the TalonSRX closed loop / open loop mode for each wheel
		if (m_closedLoopMode) {
			setClosedLoopMode();
		} else {
			setOpenLoopMode();
		}
	}

	public void initDefaultCommand() {
		// Set the default command for a subsystem here.
		// setDefaultCommand(new Command());
	}
	
	public double getMaxWheelSpeed() {
		return (m_maxWheelSpeed);
	}

	public void zeroDistanceTraveled() {
		int talonIndex = 0;
		// record current positions as "zero" for all of the Talon SRX encoders
		for (talonIndex = 0; talonIndex < kMaxNumberOfMotors; talonIndex++) {
			m_zeroPositions[talonIndex] = m_talons[talonIndex].getPosition();
		}
	}

	public double getDistanceTraveled() {
		int talonIndex = 0;
		double tempDistance = 0;
		// add up the absolute value of the distances from each individual wheel
		for (talonIndex = 0; talonIndex < kMaxNumberOfMotors; talonIndex++) {
			tempDistance += Math.abs(m_talons[talonIndex].getPosition()
					- m_zeroPositions[talonIndex]);
		}
		return (tempDistance);
	}

	public void setWheelPIDF() {
		int talonIndex = 0;
		double wheelP = 1.05;//1.02;//RobotPreferences.getWheelP();
		double wheelI = 0.0;//RobotPreferences.getWheelI();
		double wheelD = 0.0;//RobotPreferences.getWheelD();
		double wheelF = 0.416;//RobotPreferences.getWheelF();

		// set the PID values for each individual wheel
		for (talonIndex = 0; talonIndex < kMaxNumberOfMotors; talonIndex++) {
			m_talons[talonIndex].setPID(wheelP, wheelI, wheelD, wheelF, 0,
					m_voltageRampRate, 0);
		}
		DriverStation.reportError("setWheelPIDF: " + wheelP + " " + wheelI
				+ " " + wheelD + " " + wheelF + "\n", false);
	}
	
	public double getHeading() {
		return headingGyro.getFusedHeading();
	}

	public void resetHeadingGyro() {
		headingGyro.reset();
		m_desiredHeading = 0.0;
	}

	public void clearDesiredHeading() {
		m_desiredHeading = getHeading();
	}

	public void recalibrateHeadingGyro() {
		headingGyro.reset();
//		headingGyro.free();
//		headingGyro = new AnalogGyro(RobotMap.HEADING_GYRO);
//		m_desiredHeading = 0.0;
	}

	public void toggleFieldOrientedDrive() {
		m_fieldOrientedDrive = !m_fieldOrientedDrive;
		SmartDashboard.putBoolean("Field Oriented Drive",
				m_fieldOrientedDrive);
	}

	public void setClosedLoopMode() {
		int talonIndex = 0;
		m_closedLoopMode = true;
		setWheelPIDF();
		for (talonIndex = 0; talonIndex < kMaxNumberOfMotors; talonIndex++) {
			m_talons[talonIndex].changeControlMode(TalonControlMode.Speed);
			m_talons[talonIndex].enableControl();
		}
	}

	public void setOpenLoopMode() {
		int talonIndex = 0;
		m_closedLoopMode = false;
		for (talonIndex = 0; talonIndex < kMaxNumberOfMotors; talonIndex++) {
			m_talons[talonIndex].changeControlMode(TalonControlMode.PercentVbus);
			m_talons[talonIndex].enableControl();
		}
	}

	public void toggleClosedLoopMode() {
		if (!m_closedLoopMode) {
			setClosedLoopMode();
		} else {
			setOpenLoopMode();
		}
	}
	
	public void updateSmartDashboard() {

		if (Robot.DEBUG) {			
			SmartDashboard.putNumber("Front Left SRX Position",
					m_talons[kFrontLeft].getPosition() - m_zeroPositions[kFrontLeft]);
			SmartDashboard.putNumber("Front Right SRX Position",
					-(m_talons[kFrontRight].getPosition() - m_zeroPositions[kFrontRight]));
			SmartDashboard.putNumber("Back Left SRX Position",
					m_talons[kBackLeft].getPosition() - m_zeroPositions[kBackLeft]);
			SmartDashboard.putNumber("Back Right SRX Position",
					-(m_talons[kBackRight].getPosition() - m_zeroPositions[kBackRight]));

			SmartDashboard.putNumber("Front Left SRX Speed",
					m_talons[kFrontLeft].getSpeed());
			SmartDashboard.putNumber("Front Right SRX Speed",
					-m_talons[kFrontRight].getSpeed());
			SmartDashboard.putNumber("Back Left SRX Speed",
					m_talons[kBackLeft].getSpeed());
			SmartDashboard.putNumber("Back Right SRX Speed",
					-m_talons[kBackRight].getSpeed());

			SmartDashboard.putNumber("FL Desired Speed",
					m_wheelSpeeds[kFrontLeft]);
			SmartDashboard.putNumber("FR Desired Speed",
					-m_wheelSpeeds[kFrontRight]);
			SmartDashboard.putNumber("BL Desired Speed",
					m_wheelSpeeds[kBackLeft]);
			SmartDashboard.putNumber("BR Desired Speed",
					-m_wheelSpeeds[kBackRight]);
			
			SmartDashboard.putNumber("Front Left SRX Close loop Error",
					m_talons[kFrontLeft].getClosedLoopError());
			SmartDashboard.putNumber("Front Right SRX Close loop Error",
					-m_talons[kFrontRight].getClosedLoopError());
			SmartDashboard.putNumber("Back Left SRX Close loop Error",
					m_talons[kBackLeft].getClosedLoopError());
			SmartDashboard.putNumber("Back Right SRX Close loop Error",
					-m_talons[kBackRight].getClosedLoopError());

			SmartDashboard.putNumber("Front Left Current",
					Robot.pdp.getCurrent(RobotMap.DRIVE_FRONT_LEFT_PDP));
			SmartDashboard.putNumber("Front Right Current",
					Robot.pdp.getCurrent(RobotMap.DRIVE_FRONT_RIGHT_PDP));
			SmartDashboard.putNumber("Back Left Current",
					Robot.pdp.getCurrent(RobotMap.DRIVE_BACK_LEFT_PDP));
			SmartDashboard.putNumber("Back Right Current",
					Robot.pdp.getCurrent(RobotMap.DRIVE_BACK_RIGHT_PDP));

			SmartDashboard.putNumber("Front Left Output Voltage",
					m_talons[kFrontLeft].getOutputVoltage());
			SmartDashboard.putNumber("Front Right Output Voltage",
					-m_talons[kFrontRight].getOutputVoltage());
			SmartDashboard.putNumber("Back Left Output Voltage",
					m_talons[kBackLeft].getOutputVoltage());
			SmartDashboard.putNumber("Back Right Output Voltage",
					-m_talons[kBackRight].getOutputVoltage());

			SmartDashboard.putNumber("Gyro",
					Utils.twoDecimalPlaces(headingGyro.getFusedHeading()));
			
			SmartDashboard.putBoolean(  "IMU_Connected",        headingGyro.isConnected());
            SmartDashboard.putBoolean(  "IMU_IsCalibrating",    headingGyro.isCalibrating());
            SmartDashboard.putNumber(   "IMU_Yaw",              headingGyro.getYaw());
            
			SmartDashboard.putNumber("Desired Heading", m_desiredHeading);

			SmartDashboard.putBoolean("Turbo Mode", Robot.oi.driveTurboMode());
			SmartDashboard.putBoolean("Closed Loop Mode", m_closedLoopMode);
			SmartDashboard.putBoolean("Field Oriented Drive",
					m_fieldOrientedDrive);


		}
	}
	
	/**
	 * Normalize all wheel speeds if the magnitude of any wheel is greater than
	 * 1.0.
	 */
	private void normalizeAndScaleWheelSpeeds() {
		int i;
		double tempMagnitude;
		double maxMagnitude;

		// find maxMagnitude
		maxMagnitude = Math.abs(m_wheelSpeeds[0]);
		for (i = 1; i < kMaxNumberOfMotors; i++) {
			tempMagnitude = Math.abs(m_wheelSpeeds[i]);
			if (tempMagnitude > maxMagnitude) {
				maxMagnitude = tempMagnitude;
			}
		}

		// if any wheel has a magnitude greater than 1.0, reduce all to fit in
		// range
		if (maxMagnitude > 1.0) {
			for (i = 0; i < kMaxNumberOfMotors; i++) {
				m_wheelSpeeds[i] = m_wheelSpeeds[i] / maxMagnitude;
			}
		}

		// if in closedLoopMode, scale wheels to be speeds, rather than power
		// percentage
		if (m_closedLoopMode) {
			for (i = 0; i < kMaxNumberOfMotors; i++) {
				m_wheelSpeeds[i] = m_wheelSpeeds[i] * m_maxWheelSpeed;
			}
		}
	}


	/**
	 * Correct any inverted motors
	 */
	private void correctInvertedMotors() {
		int i;

		for (i = 0; i < kMaxNumberOfMotors; i++) {
			m_wheelSpeeds[i] = m_wheelSpeeds[i] * m_invertedMotors[i];
		}
	}

	/**
	 * Rotate a vector in Cartesian space.
	 */
	protected static double[] rotateVector(double x, double y, double angle) {
		double cosA = Math.cos(angle * (3.14159 / 180.0));
		double sinA = Math.sin(angle * (3.14159 / 180.0));
		double out[] = new double[2];
		out[0] = x * cosA - y * sinA;
		out[1] = x * sinA + y * cosA;
		return out;
	}
	
	/**
	 * Drive method for Mecanum wheeled robots.
	 *
	 * A method for driving with Mecanum wheeled robots. There are 4 wheels on
	 * the robot, arranged so that the front and back wheels are toed in 45
	 * degrees. When looking at the wheels from the top, the roller axles should
	 * form an X across the robot.
	 *
	 * This is designed to be directly driven by joystick axes.
	 *
	 * @param x
	 *            The speed that the robot should drive in the X direction.
	 *            [-1.0..1.0]
	 * @param y
	 *            The speed that the robot should drive in the Y direction.
	 *            [-1.0..1.0]
	 * @param rotation
	 *            The rate of rotation for the robot that is completely
	 *            independent of the translation. [-1.0..1.0]
	 */
	public void mecanumDriveTeleop(double xIn, double yIn, double rotation) {

		// check for the presence of the special "crawl" commands and do those
		// if commanded
		if (Robot.oi.crawlBackward()) {
			yIn = 0.0;
			xIn = -CRAWL_INPUT;
			rotation = 0.0;
		}

		if (Robot.oi.crawlForward()) {
			yIn = 0.0;
			xIn = CRAWL_INPUT;
			rotation = 0.0;
		}

		if (Robot.oi.crawlRight()) {
			yIn = CRAWL_INPUT;
			xIn = 0.0;
			rotation = 0.0;
		}

		if (Robot.oi.crawlLeft()) {
			yIn = -CRAWL_INPUT;
			xIn = 0.0;
			rotation = 0.0;
		}

		// Compensate for gyro angle if field-oriented drive is desired
		if (m_fieldOrientedDrive) {
			// rotate the vector to be "robot-centric"
			double rotated[] = rotateVector(xIn, yIn, getHeading());
			xIn = rotated[0];
			yIn = rotated[1];
		}

		// check to see if forward/back, strafe, and rotation are being
		// commanded.
		// values with magnitude < 0.07 are just "centering noise" and set to
		// 0.0
		if ((-0.07 < xIn) && (xIn < 0.07)) {
			xIn = 0.0;
		}
		if ((-0.07 < yIn) && (yIn < 0.07)) {
			yIn = 0.0;
		}
		if ((-0.07 < rotation) && (rotation < 0.07)) {
			rotation = 0.0;
		}

		// scale inputs to compensate for misbalance of speeds in different
		// directions
		xIn = xIn * STRAFE_FACTOR;
		SmartDashboard.putNumber("xIn = ", xIn);
		yIn = yIn * FORWARD_BACKWARD_FACTOR;
		SmartDashboard.putNumber("yIn = ", yIn);
		rotation = rotation * ROTATION_FACTOR;

		// apply "slowFactor" if not in "Turbo Mode"
		if (!Robot.oi.driveTurboMode()) {
			xIn = xIn * SLOW_FACTOR;
			yIn = yIn * SLOW_FACTOR;
			rotation = rotation * SLOW_FACTOR;
		}

		// update count of iterations since rotation last commanded
		if ((-0.01 < rotation) && (rotation < 0.01)) {
			// rotation is practically zero, so just set it to zero and
			// increment iterations
			rotation = 0.0;
			m_iterationsSinceRotationCommanded++;
		} else {
			// rotation is being commanded, so clear iteration counter
			m_iterationsSinceRotationCommanded = 0;
		}

		// preserve heading when recently stopped commanding rotations
		if (m_iterationsSinceRotationCommanded == 5) {
			m_desiredHeading = getHeading();
		} else if (m_iterationsSinceRotationCommanded > 5) {
			rotation = (m_desiredHeading - getHeading()) / 40.0;
		}

		// if no directions being commanded and driving in teleop, then let the "AutoInTeleop" take place
		if (m_drivingAutoInTeleop) {
			return;
		}
		
		mecanumDriveCartesian(xIn, yIn, rotation);
	}

	public void mecanumDriveAutonomous(double xIn, double yIn, double rotation,
			double heading) {
		m_desiredHeading = heading;

		// preserve heading if no rotation is commanded
		if ((-0.01 < rotation) && (rotation < 0.01)) {
			rotation = (m_desiredHeading - getHeading()) / 40.0;
		}
		mecanumDriveCartesian(xIn, yIn, rotation);
	}
	
	public void mecanumDriveAutoInTeleopFinished() {
		m_drivingAutoInTeleop = false;
	}
	
	public void mecanumDriveAutoInTeleop(double xIn, double yIn, double rotation) {
		m_drivingAutoInTeleop = true;
		
		// update count of iterations since rotation last commanded
		if ((-0.01 < rotation) && (rotation < 0.01)) {
			// rotation is practically zero, so just set it to zero and
			// increment iterations
			rotation = 0.0;
			m_iterationsSinceRotationCommanded++;
		} else {
			// rotation is being commanded, so clear iteration counter
			m_iterationsSinceRotationCommanded = 0;
		}

		// preserve heading when recently stopped commanding rotations
		if (m_iterationsSinceRotationCommanded == 5) {
			m_desiredHeading = getHeading();
		} else if (m_iterationsSinceRotationCommanded > 5) {
			rotation = (m_desiredHeading - getHeading()) / 40.0;
		}
		
		mecanumDriveCartesian(xIn, yIn, rotation);
	}

	public void mecanumDriveCartesian(double xIn, double yIn, double rotation) {
		int talonIndex = 0;

		m_wheelSpeeds[kFrontLeft] = xIn + yIn + rotation;
		m_wheelSpeeds[kFrontRight] = -xIn + yIn - rotation;
		m_wheelSpeeds[kBackLeft] = -xIn + yIn + rotation;
		m_wheelSpeeds[kBackRight] = xIn + yIn - rotation;

		normalizeAndScaleWheelSpeeds();
		correctInvertedMotors();

		// want to do all the sets immediately after one another to minimize
		// delay between commands
		// set all Talon SRX encoder values to zero
		SmartDashboard.putNumber("Wheel Speed FL", m_wheelSpeeds[kFrontLeft]);
		SmartDashboard.putNumber("Wheel Speed FR", m_wheelSpeeds[kFrontRight]);
		SmartDashboard.putNumber("Wheel Speed BL", m_wheelSpeeds[kBackLeft]);
		SmartDashboard.putNumber("Wheel Speed BR", m_wheelSpeeds[kBackRight]);
		for (talonIndex = 0; talonIndex < kMaxNumberOfMotors; talonIndex++) {
			m_talons[talonIndex].set(m_wheelSpeeds[talonIndex]);
			
		}

	}
}

